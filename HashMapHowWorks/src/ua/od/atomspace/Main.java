package ua.od.atomspace;

import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("Some", 2);
        hashMap.get("Some");
        System.out.println(hashMap);
    }
}

// hashMap хранит пары ключ-значение
// внутри hashMap находится обычный массив, элементами которого являются связанные списки [*->*->*->*] [*->*->] []
// каждый элемента массива (сам связанный список) называют бакетом. Элементами списка являются узлы (Node), у которых есть поля
// value, key, hashCode. по факту Entry хранится в Node в качестве пары ключ-значение
// При создании мапы по дэфолту 16 бакетов, если не передать другое значение.
// как происходят операции с мапой: высчитывается хэш ключа, с переопределенного метода hashCode(). высчитывается индекс с помощью хэшкода,
// текущего размера и операции побитового умножения. Определивши индекс попадаем в бакет и проходимся по его хэшкодам.
// если встретили с таким же хэшкодом, то есть 2 варианта: коллизия или идентичный элемент в качестве
// на key в Node вызывается метод equals в который передается объект ключа сравниваемого
// если объекты равны, то происходит либо удаление Node, либо возвращение value, либо перезапись в value (в зависимости от вызваного метода)
// если объекты по equals не равны, то это случай коллизии и поэтому происходит дальнейший поиск нужного элемента (равного по equals)
// если такой объект не найден, то происходит добавление нового Node в конец списка, либо возвращение null, если объект не найден (в зависимости от вызваного метода)
// нужно заранее создавать столько бакетов, сколько будет элементов в мапе, чтобы сложность алгоритма не была высокой
// если нет коллизий, то сложность алгоритма O(1) - константая  (это идеально)
// вообще сложность мапы стремится к O(log n)
// если функция хэшкод у объектов галимо реализована (возвращается константное значение), то сложность алгоритма линейная O(n)